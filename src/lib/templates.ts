import * as HB from 'handlebars';
import {TemplateData, TemplateTypes} from '../types';
import {existsSync, readFileSync, writeFileSync} from 'fs';
import {join, resolve} from 'path';
import consola from 'consola';

// Constants
const TEMPLATE_EXTENSION = '.tpl';
const JS_EXTENSION = '.js';
const SEPARATOR = '-';

/**
 * Formats single-digit numbers with a leading zero.
 * @param number {number} Number to format.
 * @return {string} Formatted number.
 */
const formatSingleDigit = (number: number): string => {
  return number < 10 ? `0${number}` : number.toString();
};

/**
 * Gets the current timestamp in YYYYMMDDHHmmss format.
 * @return {string} Formatted timestamp.
 */
const getCurrentTimestamp = (): string => {
  const date = new Date();
  return [
    date.getUTCFullYear(),
    formatSingleDigit(date.getUTCMonth() + 1),
    formatSingleDigit(date.getUTCDate()),
    formatSingleDigit(date.getUTCHours()),
    formatSingleDigit(date.getUTCMinutes()),
    formatSingleDigit(date.getUTCSeconds()),
  ].join('');
};

/**
 * Generates migration filename based on template name and data.
 * @param templateName {TemplateTypes} Type of template.
 * @param data {TemplateData} Template data.
 * @return {string} Generated filename.
 */

const generateFileName = (
  templateName: TemplateTypes,
  {tableName, columnName}: TemplateData
): string => {
  const timestamp = getCurrentTimestamp();
  switch (templateName) {
    case 'createTable':
      return `${timestamp}${SEPARATOR}create${SEPARATOR}${tableName}${JS_EXTENSION}`;
    case 'removeTable':
      return `${timestamp}${SEPARATOR}remove${SEPARATOR}${tableName}${JS_EXTENSION}`;
    case 'addColumn':
      return `${timestamp}${SEPARATOR}add${SEPARATOR}${columnName}${SEPARATOR}to${SEPARATOR}${tableName}${JS_EXTENSION}`;
    case 'removeColumn':
      return `${timestamp}${SEPARATOR}remove${SEPARATOR}${columnName}${SEPARATOR}from${SEPARATOR}${tableName}${JS_EXTENSION}`;
    case 'modifyColumn':
      return `${timestamp}${SEPARATOR}modify${SEPARATOR}${columnName}${SEPARATOR}on${SEPARATOR}${tableName}${JS_EXTENSION}`;
    default:
      return `${timestamp}${SEPARATOR}migration${JS_EXTENSION}`;
  }
};

/**
 * Registers Handlebars helper for formatting attributes.
 */
const registerHandlebarsHelper = () => {
  HB.registerHelper(
    'formatAttributes',
    (attributes: Record<string, unknown>, indent: string) => {
      const formatValue = (key: string, value: unknown): string => {
        if (key === 'type') return `Sequelize.${value as string}`;
        switch (typeof value) {
          case 'string':
            return `'${value}'`;
          case 'object':
            return JSON.stringify(value)
              .replace(/"([^"]+)":/g, '$1:')
              .replace(/"/g, "'");
          default:
            return String(value); // This should take care of the type error for 'value'.
        }
      };

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const {Model, _modelAttribute, field, _autoGenerated, ...rest} =
        attributes;

      return (
        Object.keys(rest)
          .filter(key => typeof rest[key] !== 'function')
          .map(attr => `${attr}: ${formatValue(attr, attributes[attr])}`)
          .join(`,\n${' '.repeat(Number(indent))}`) + ','
      );
    }
  );
};

/**
 * Renders the template with given data and writes it to specified path.
 * @param templateName {TemplateTypes} Type of template.
 * @param data {TemplateData} Template data.
 * @param migrationsPath {string} Path to write the file.
 */
const renderTemplate = async (
  templateName: TemplateTypes,
  data: TemplateData,
  migrationsPath: string
) => {
  // await sleep(1000);
  const templatePath = resolve(
    __dirname,
    '../../templates',
    `${templateName}${TEMPLATE_EXTENSION}`
  );
  if (!existsSync(templatePath)) {
    throw new Error(`Template not found: ${templateName}`);
  }

  registerHandlebarsHelper();

  const templateContent = readFileSync(templatePath).toString();
  const renderedContent = HB.compile(templateContent)(data);
  const fileName = generateFileName(templateName, data);

  writeFileSync(join(migrationsPath, fileName), renderedContent);
  consola.success(`${fileName} Created!`);
};

export default renderTemplate;
